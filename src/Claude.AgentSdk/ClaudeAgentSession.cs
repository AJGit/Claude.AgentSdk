using System.Runtime.CompilerServices;
using Claude.AgentSdk.Logging;
using Claude.AgentSdk.Messages;
using Claude.AgentSdk.Metrics;
using Claude.AgentSdk.Protocol;
using Microsoft.Extensions.Logging;

namespace Claude.AgentSdk;

/// <summary>
///     Represents an active bidirectional session with the Claude CLI.
/// </summary>
/// <remarks>
///     <para>
///         Sessions are created via <see cref="ClaudeAgentClient.CreateSessionAsync" /> and own their
///         lifecycle independently of the client. Each session has its own <see cref="CancellationTokenSource" />
///         for clean shutdown semantics.
///     </para>
///     <para>
///         The session provides methods for sending messages, receiving responses, and controlling
///         the Claude agent (interrupt, set model, etc.).
///     </para>
/// </remarks>
public sealed class ClaudeAgentSession : IAsyncDisposable
{
    private static readonly JsonSerializerOptions _jsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    private readonly QueryHandler _handler;
    private readonly ILogger<ClaudeAgentSession>? _logger;
    private readonly IDisposable? _logScope;

    private readonly CancellationTokenSource _sessionCts = new();
    private readonly string? _sessionDisplayName;
    private bool _disposed;

    internal ClaudeAgentSession(
        QueryHandler handler,
        string? sessionDisplayName = null,
        ILogger<ClaudeAgentSession>? logger = null)
    {
        _handler = handler;
        _sessionDisplayName = sessionDisplayName;
        _logger = logger;
        SessionId = GenerateSessionId();

        // Wire up metrics callback from QueryHandler
        _handler.OnResultMessage = HandleResultMessage;

        // Create logging scope with session ID for log tracing
        if (_logger is not null)
        {
            _logScope = _logger.BeginCorrelationScope(SessionId);
            Log.SessionCreated(_logger, SessionId);
        }
    }

    /// <summary>
    ///     Gets the unique session identifier.
    /// </summary>
    /// <remarks>
    ///     This ID is included in all <see cref="MetricsEvent" /> callbacks.
    ///     You can use this to correlate metrics with your own tracking systems.
    /// </remarks>
    public string SessionId { get; }

    /// <summary>
    ///     Gets the unique correlation identifier for this session, used for logging.
    /// </summary>
    /// <remarks>
    ///     This is a synthetic ID generated by the SDK for log correlation purposes.
    ///     It is not the same as any protocol-level session_id from the Claude CLI.
    /// </remarks>
    public string CorrelationId => SessionId;

    /// <summary>
    ///     Callback invoked when metrics events occur (token usage, costs).
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Set this callback to receive metrics for database logging or your own aggregation.
    ///         Each event includes the <see cref="SessionId" /> so you can track metrics per session.
    ///     </para>
    ///     <para>
    ///         Events are fired after each ResultMessage with token/cost/duration data (EventType = "usage").
    ///     </para>
    /// </remarks>
    /// <example>
    ///     <code>
    /// session.OnMetrics = async evt =&gt;
    /// {
    ///     await db.SaveAsync(new MetricsLog
    ///     {
    ///         SessionId = evt.SessionId,
    ///         InputTokens = evt.InputTokens,
    ///         OutputTokens = evt.OutputTokens,
    ///         CostUsd = evt.CostUsd,
    ///         EventType = evt.EventType
    ///     });
    /// };
    /// </code>
    /// </example>
    public Func<MetricsEvent, ValueTask>? OnMetrics { get; set; }

    /// <summary>
    ///     Gets a cancellation token that is cancelled when the session is disposed.
    /// </summary>
    public CancellationToken SessionCancellationToken => _sessionCts.Token;

    /// <summary>
    ///     Gets the exception that caused the message stream to terminate, if any.
    /// </summary>
    /// <remarks>
    ///     This is null if the stream ended normally (cancellation or EOF).
    ///     Check this property after the message stream completes to distinguish
    ///     between normal termination and failure.
    /// </remarks>
    public Exception? TerminalException => _handler.TerminalException;

    /// <summary>
    ///     Disposes the session and releases all resources.
    /// </summary>
    public async ValueTask DisposeAsync()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;

        if (_logger is not null)
        {
            Log.SessionDisposing(_logger);
        }

        // Clear callback to prevent any more events
        OnMetrics = null;
        _handler.OnResultMessage = null;

        // Cancel the session token to signal shutdown
        await _sessionCts.CancelAsync().ConfigureAwait(false);

        // Dispose the handler (which disposes transport)
        await _handler.DisposeAsync().ConfigureAwait(false);

        _sessionCts.Dispose();
        _logScope?.Dispose();
    }

    /// <summary>
    ///     Cancels the session, stopping all pending operations.
    /// </summary>
    /// <remarks>
    ///     This method cancels the session's internal cancellation token, which will
    ///     cause all pending operations to throw <see cref="OperationCanceledException" />.
    ///     The session should be disposed after cancellation.
    /// </remarks>
    public async Task CancelAsync()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (_logger is not null)
        {
            Log.SessionCancelled(_logger);
        }

        await _sessionCts.CancelAsync().ConfigureAwait(false);
    }

    /// <summary>
    ///     Send a message to the Claude agent.
    /// </summary>
    /// <param name="content">The message content to send.</param>
    /// <param name="sessionId">
    ///     Optional Claude CLI <c>session_id</c> to continue/resume an existing CLI session.
    /// </param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task SendAsync(
        string content,
        string? sessionId = null,
        CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        var message = new UserMessageEnvelope
        {
            Message = new UserMessagePayload { Content = content },
            SessionId = sessionId
        };

        await _handler.SendMessageAsync(message, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Receive messages from the Claude agent.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>An async enumerable of messages from Claude.</returns>
    /// <remarks>
    ///     This is a continuous stream that does not stop automatically.
    ///     Use <see cref="ReceiveResponseAsync" /> to receive messages until a ResultMessage.
    /// </remarks>
    public async IAsyncEnumerable<Message> ReceiveAsync(
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await foreach (var message in _handler.ReceiveMessagesAsync(linkedCts.Token).ConfigureAwait(false))
        {
            yield return message;
        }
    }

    /// <summary>
    ///     Receive messages until and including a ResultMessage.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>An async enumerable of messages that terminates after a ResultMessage.</returns>
    /// <remarks>
    ///     Unlike <see cref="ReceiveAsync" />, this method automatically terminates
    ///     after yielding a ResultMessage (which indicates the response is complete).
    ///     The ResultMessage IS included in the yielded messages.
    /// </remarks>
    public async IAsyncEnumerable<Message> ReceiveResponseAsync(
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await foreach (var message in _handler.ReceiveMessagesAsync(linkedCts.Token).ConfigureAwait(false))
        {
            yield return message;

            // Stop after a terminal ResultMessage (not partial results from tool use)
            if (message is ResultMessage result && result.Subtype != "partial")
            {
                yield break;
            }
        }
    }

    /// <summary>
    ///     Send an interrupt signal to stop the current operation.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task InterruptAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.InterruptAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Change the permission mode.
    /// </summary>
    /// <param name="mode">The new permission mode.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task SetPermissionModeAsync(PermissionMode mode, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.SetPermissionModeAsync(mode, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Change the model.
    /// </summary>
    /// <param name="model">The model to use.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task SetModelAsync(string model, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.SetModelAsync(model, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get the list of supported slash commands as raw JSON.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>JSON element containing supported commands.</returns>
    public async Task<JsonElement> GetSupportedCommandsAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        return await _handler.GetSupportedCommandsAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get the list of supported slash commands.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>List of available slash commands.</returns>
    public async Task<IReadOnlyList<SlashCommand>> GetSupportedCommandsTypedAsync(
        CancellationToken cancellationToken = default)
    {
        var json = await GetSupportedCommandsAsync(cancellationToken).ConfigureAwait(false);
        return json.Deserialize<List<SlashCommand>>(_jsonOptions) ?? [];
    }

    /// <summary>
    ///     Get the list of supported models as raw JSON.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>JSON element containing supported models.</returns>
    public async Task<JsonElement> GetSupportedModelsAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        return await _handler.GetSupportedModelsAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get the list of supported models.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>List of available models with display info.</returns>
    public async Task<IReadOnlyList<ModelInfo>> GetSupportedModelsTypedAsync(
        CancellationToken cancellationToken = default)
    {
        var json = await GetSupportedModelsAsync(cancellationToken).ConfigureAwait(false);
        return json.Deserialize<List<ModelInfo>>(_jsonOptions) ?? [];
    }

    /// <summary>
    ///     Get MCP server status as raw JSON.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>JSON element containing MCP server status.</returns>
    public async Task<JsonElement> GetMcpServerStatusAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        return await _handler.GetMcpServerStatusAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get MCP server status.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>List of MCP server status information.</returns>
    public async Task<IReadOnlyList<McpServerStatusInfo>> GetMcpServerStatusTypedAsync(
        CancellationToken cancellationToken = default)
    {
        var json = await GetMcpServerStatusAsync(cancellationToken).ConfigureAwait(false);
        return json.Deserialize<List<McpServerStatusInfo>>(_jsonOptions) ?? [];
    }

    /// <summary>
    ///     Get account information as raw JSON.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>JSON element containing account information.</returns>
    public async Task<JsonElement> GetAccountInfoAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        return await _handler.GetAccountInfoAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get account information.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>Account information for the authenticated user.</returns>
    public async Task<AccountInfo> GetAccountInfoTypedAsync(CancellationToken cancellationToken = default)
    {
        var json = await GetAccountInfoAsync(cancellationToken).ConfigureAwait(false);
        return json.Deserialize<AccountInfo>(_jsonOptions) ?? new AccountInfo();
    }

    /// <summary>
    ///     Rewind files to a specific user message state.
    /// </summary>
    /// <param name="userMessageId">The user message ID to rewind to.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <remarks>
    ///     <para>
    ///         This method restores file state to what it was at the specified user message.
    ///         Requires <see cref="ClaudeAgentOptions.EnableFileCheckpointing" /> to be enabled.
    ///     </para>
    ///     <para>
    ///         Use this in combination with session resumption to replay or undo file changes
    ///         made during a conversation.
    ///     </para>
    /// </remarks>
    public async Task<RewindFilesResult> RewindFilesAsync(string userMessageId, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        var json = await _handler.RewindFilesAsync(userMessageId, linkedCts.Token).ConfigureAwait(false);
        return json.Deserialize<RewindFilesResult>(_jsonOptions) ?? new RewindFilesResult();
    }

    /// <summary>
    ///     Set the maximum thinking tokens during a session.
    /// </summary>
    /// <param name="maxTokens">The maximum thinking token count, or null to reset.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task SetMaxThinkingTokensAsync(int? maxTokens, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.SetMaxThinkingTokensAsync(maxTokens ?? 0, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Reconnect to an MCP server.
    /// </summary>
    /// <param name="serverName">The MCP server name.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task ReconnectMcpServerAsync(string serverName, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.ReconnectMcpServerAsync(serverName, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Toggle an MCP server on or off.
    /// </summary>
    /// <param name="serverName">The MCP server name.</param>
    /// <param name="enabled">Whether to enable or disable the server.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task ToggleMcpServerAsync(string serverName, bool enabled, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.ToggleMcpServerAsync(serverName, enabled, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Configure MCP servers dynamically.
    /// </summary>
    /// <param name="servers">The MCP server configurations keyed by server name.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>Result indicating which servers were added, removed, or had errors.</returns>
    public async Task<McpSetServersResult> SetMcpServersAsync(
        IDictionary<string, McpServerConfig> servers,
        CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        var json = await _handler.SetMcpServersAsync(servers, linkedCts.Token).ConfigureAwait(false);
        return json.Deserialize<McpSetServersResult>(_jsonOptions) ?? new McpSetServersResult();
    }

    private void HandleResultMessage(ResultMessage result)
    {
        if (OnMetrics is not { } callback || _disposed)
        {
            return;
        }

        var evt = MetricsHelper.FromResultMessage(
            result,
            SessionId,
            _sessionDisplayName,
            _handler.CurrentModel);
        MetricsHelper.FireAndForget(evt, callback);
    }
    private static string GenerateSessionId()
    {
        return $"sess_{DateTime.UtcNow:yyyyMMddHHmmss}_{Guid.NewGuid():N}"[..32];
    }
}
