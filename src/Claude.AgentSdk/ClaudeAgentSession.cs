using System.Runtime.CompilerServices;
using Claude.AgentSdk.Logging;
using Claude.AgentSdk.Messages;
using Claude.AgentSdk.Protocol;
using Microsoft.Extensions.Logging;

namespace Claude.AgentSdk;

/// <summary>
///     Represents an active bidirectional session with the Claude CLI.
/// </summary>
/// <remarks>
///     <para>
///         Sessions are created via <see cref="ClaudeAgentClient.CreateSessionAsync" /> and own their
///         lifecycle independently of the client. Each session has its own <see cref="CancellationTokenSource" />
///         for clean shutdown semantics.
///     </para>
///     <para>
///         The session provides methods for sending messages, receiving responses, and controlling
///         the Claude agent (interrupt, set model, etc.).
///     </para>
/// </remarks>
public sealed class ClaudeAgentSession : IAsyncDisposable
{
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    private readonly QueryHandler _handler;
    private readonly ILogger<ClaudeAgentSession>? _logger;
    private readonly IDisposable? _logScope;

    private readonly CancellationTokenSource _sessionCts = new();
    private bool _disposed;

    internal ClaudeAgentSession(
        QueryHandler handler,
        ILogger<ClaudeAgentSession>? logger = null)
    {
        _handler = handler;
        _logger = logger;
        CorrelationId = GenerateCorrelationId();

        // Create logging scope with correlation ID for log tracing
        if (_logger is not null)
        {
            _logScope = _logger.BeginCorrelationScope(CorrelationId);
            Log.SessionCreated(_logger, CorrelationId);
        }
    }

    /// <summary>
    ///     Gets the unique correlation identifier for this session, used for logging.
    /// </summary>
    /// <remarks>
    ///     This is a synthetic ID generated by the SDK for log correlation purposes.
    ///     It is not the same as any protocol-level session_id from the Claude CLI.
    /// </remarks>
    public string CorrelationId { get; }

    /// <summary>
    ///     Gets a cancellation token that is cancelled when the session is disposed.
    /// </summary>
    public CancellationToken SessionCancellationToken => _sessionCts.Token;

    /// <summary>
    ///     Gets the exception that caused the message stream to terminate, if any.
    /// </summary>
    /// <remarks>
    ///     This is null if the stream ended normally (cancellation or EOF).
    ///     Check this property after the message stream completes to distinguish
    ///     between normal termination and failure.
    /// </remarks>
    public Exception? TerminalException => _handler.TerminalException;

    /// <summary>
    ///     Disposes the session and releases all resources.
    /// </summary>
    public async ValueTask DisposeAsync()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;

        if (_logger is not null)
        {
            Log.SessionDisposing(_logger);
        }

        // Cancel the session token to signal shutdown
        await _sessionCts.CancelAsync().ConfigureAwait(false);

        // Dispose the handler (which disposes transport)
        await _handler.DisposeAsync().ConfigureAwait(false);

        _sessionCts.Dispose();
        _logScope?.Dispose();
    }

    /// <summary>
    ///     Cancels the session, stopping all pending operations.
    /// </summary>
    /// <remarks>
    ///     This method cancels the session's internal cancellation token, which will
    ///     cause all pending operations to throw <see cref="OperationCanceledException" />.
    ///     The session should be disposed after cancellation.
    /// </remarks>
    public async Task CancelAsync()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (_logger is not null)
        {
            Log.SessionCancelled(_logger);
        }

        await _sessionCts.CancelAsync().ConfigureAwait(false);
    }

    /// <summary>
    ///     Send a message to the Claude agent.
    /// </summary>
    /// <param name="content">The message content to send.</param>
    /// <param name="sessionId">
    ///     Optional Claude CLI <c>session_id</c> to continue/resume an existing CLI session.
    /// </param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task SendAsync(
        string content,
        string? sessionId = null,
        CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        var message = new UserMessageEnvelope
        {
            Message = new UserMessagePayload { Content = content },
            SessionId = sessionId
        };

        await _handler.SendMessageAsync(message, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Receive messages from the Claude agent.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>An async enumerable of messages from Claude.</returns>
    /// <remarks>
    ///     This is a continuous stream that does not stop automatically.
    ///     Use <see cref="ReceiveResponseAsync" /> to receive messages until a ResultMessage.
    /// </remarks>
    public async IAsyncEnumerable<Message> ReceiveAsync(
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await foreach (var message in _handler.ReceiveMessagesAsync(linkedCts.Token).ConfigureAwait(false))
        {
            yield return message;
        }
    }

    /// <summary>
    ///     Receive messages until and including a ResultMessage.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>An async enumerable of messages that terminates after a ResultMessage.</returns>
    /// <remarks>
    ///     Unlike <see cref="ReceiveAsync" />, this method automatically terminates
    ///     after yielding a ResultMessage (which indicates the response is complete).
    ///     The ResultMessage IS included in the yielded messages.
    /// </remarks>
    public async IAsyncEnumerable<Message> ReceiveResponseAsync(
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await foreach (var message in _handler.ReceiveMessagesAsync(linkedCts.Token).ConfigureAwait(false))
        {
            yield return message;

            // Stop after a terminal ResultMessage (not partial results from tool use)
            if (message is ResultMessage result && result.Subtype != "partial")
            {
                yield break;
            }
        }
    }

    /// <summary>
    ///     Send an interrupt signal to stop the current operation.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task InterruptAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.InterruptAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Change the permission mode.
    /// </summary>
    /// <param name="mode">The new permission mode.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task SetPermissionModeAsync(PermissionMode mode, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.SetPermissionModeAsync(mode, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Change the model.
    /// </summary>
    /// <param name="model">The model to use.</param>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    public async Task SetModelAsync(string model, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        await _handler.SetModelAsync(model, linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get the list of supported slash commands as raw JSON.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>JSON element containing supported commands.</returns>
    public async Task<JsonElement> GetSupportedCommandsAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        return await _handler.GetSupportedCommandsAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get the list of supported slash commands.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>List of available slash commands.</returns>
    public async Task<IReadOnlyList<SlashCommand>> GetSupportedCommandsTypedAsync(
        CancellationToken cancellationToken = default)
    {
        var json = await GetSupportedCommandsAsync(cancellationToken).ConfigureAwait(false);
        return json.Deserialize<List<SlashCommand>>(JsonOptions) ?? [];
    }

    /// <summary>
    ///     Get the list of supported models as raw JSON.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>JSON element containing supported models.</returns>
    public async Task<JsonElement> GetSupportedModelsAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        return await _handler.GetSupportedModelsAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get the list of supported models.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>List of available models with display info.</returns>
    public async Task<IReadOnlyList<ModelInfo>> GetSupportedModelsTypedAsync(
        CancellationToken cancellationToken = default)
    {
        var json = await GetSupportedModelsAsync(cancellationToken).ConfigureAwait(false);
        return json.Deserialize<List<ModelInfo>>(JsonOptions) ?? [];
    }

    /// <summary>
    ///     Get MCP server status as raw JSON.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>JSON element containing MCP server status.</returns>
    public async Task<JsonElement> GetMcpServerStatusAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        return await _handler.GetMcpServerStatusAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get MCP server status.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>List of MCP server status information.</returns>
    public async Task<IReadOnlyList<McpServerStatusInfo>> GetMcpServerStatusTypedAsync(
        CancellationToken cancellationToken = default)
    {
        var json = await GetMcpServerStatusAsync(cancellationToken).ConfigureAwait(false);
        return json.Deserialize<List<McpServerStatusInfo>>(JsonOptions) ?? [];
    }

    /// <summary>
    ///     Get account information as raw JSON.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>JSON element containing account information.</returns>
    public async Task<JsonElement> GetAccountInfoAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _sessionCts.Token, cancellationToken);

        return await _handler.GetAccountInfoAsync(linkedCts.Token).ConfigureAwait(false);
    }

    /// <summary>
    ///     Get account information.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for this operation.</param>
    /// <returns>Account information for the authenticated user.</returns>
    public async Task<AccountInfo> GetAccountInfoTypedAsync(CancellationToken cancellationToken = default)
    {
        var json = await GetAccountInfoAsync(cancellationToken).ConfigureAwait(false);
        return json.Deserialize<AccountInfo>(JsonOptions) ?? new AccountInfo();
    }

    private static string GenerateCorrelationId()
    {
        return $"corr_{DateTime.UtcNow:yyyyMMddHHmmss}_{Guid.NewGuid():N}"[..32];
    }
}
