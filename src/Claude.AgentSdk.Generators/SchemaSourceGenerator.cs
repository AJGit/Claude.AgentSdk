using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Claude.AgentSdk.Generators;

/// <summary>
///     Source generator that creates compile-time JSON schema generation for types
///     marked with [GenerateSchema].
/// </summary>
[Generator]
public sealed class SchemaSourceGenerator : IIncrementalGenerator
{
    private const string GenerateSchemaAttribute = "Claude.AgentSdk.Attributes.GenerateSchemaAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all types with [GenerateSchema]
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateType(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndTypes = context.CompilationProvider.Combine(typeDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndTypes, static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsCandidateType(SyntaxNode node)
    {
        return node is TypeDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static TypeDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;

        foreach (var attributeList in typeDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (symbol is IMethodSymbol methodSymbol)
                {
                    var attributeType = methodSymbol.ContainingType.ToDisplayString();
                    if (attributeType == GenerateSchemaAttribute)
                    {
                        return typeDeclaration;
                    }
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax?> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var typeDeclaration in types.Distinct())
        {
            if (typeDeclaration is null)
            {
                continue;
            }

            var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration);

            if (typeSymbol is null)
            {
                continue;
            }

            var source = GenerateSchemaExtension(typeSymbol);
            context.AddSource($"{typeSymbol.Name}SchemaExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateSchemaExtension(INamedTypeSymbol typeSymbol)
    {
        var typeName = typeSymbol.Name;
        var typeNamespace = typeSymbol.ContainingNamespace.ToDisplayString();
        var fullTypeName = typeSymbol.ToDisplayString();

        var schemaJson = GenerateSchemaJson(typeSymbol);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine();
        sb.AppendLine($"namespace {typeNamespace};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"///     Generated JSON schema extensions for <see cref=\"{typeName}\"/>.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class {typeName}SchemaExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    ///     Pre-generated JSON schema string for <see cref=\"{typeName}\"/>.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public const string SchemaJson = @\"{EscapeVerbatimString(schemaJson)}\";");
        sb.AppendLine();
        sb.AppendLine("    private static JsonDocument? _parsedSchema;");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    ///     Gets the JSON schema for <see cref=\"{typeName}\"/> as a JsonElement.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static JsonElement GetSchema(this {fullTypeName}? _)");
        sb.AppendLine("    {");
        sb.AppendLine("        _parsedSchema ??= JsonDocument.Parse(SchemaJson);");
        sb.AppendLine("        return _parsedSchema.RootElement;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    ///     Gets the JSON schema for <see cref=\"{typeName}\"/> as a JsonElement (static version).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static JsonElement GetSchemaElement()");
        sb.AppendLine("    {");
        sb.AppendLine("        _parsedSchema ??= JsonDocument.Parse(SchemaJson);");
        sb.AppendLine("        return _parsedSchema.RootElement;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateSchemaJson(INamedTypeSymbol typeSymbol)
    {
        var properties = new List<(string name, string type, bool required)>();

        // Check if it's a record with primary constructor
        if (typeSymbol.IsRecord)
        {
            // For records, get parameters from the primary constructor
            var primaryConstructor = typeSymbol.InstanceConstructors
                .FirstOrDefault(c => c.Parameters.Length > 0 && !c.IsImplicitlyDeclared);

            if (primaryConstructor != null)
            {
                foreach (var param in primaryConstructor.Parameters)
                {
                    var jsonType = GetJsonSchemaType(param.Type);
                    var required = !param.HasExplicitDefaultValue &&
                                   param.Type.NullableAnnotation != NullableAnnotation.Annotated;
                    properties.Add((ToCamelCase(param.Name), jsonType, required));
                }
            }
        }

        // Also get public properties
        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is IPropertySymbol property &&
                property.DeclaredAccessibility == Accessibility.Public &&
                !property.IsStatic &&
                property.GetMethod != null)
            {
                // Skip if already added from constructor
                var camelName = ToCamelCase(property.Name);
                if (properties.Any(p => p.name == camelName))
                {
                    continue;
                }

                var jsonType = GetJsonSchemaType(property.Type);
                var required = property.Type.NullableAnnotation != NullableAnnotation.Annotated &&
                               !property.Type.IsValueType;
                properties.Add((camelName, jsonType, required));
            }
        }

        // Build JSON schema
        var sb = new StringBuilder();
        sb.Append("{\"type\":\"object\",\"properties\":{");

        var first = true;
        foreach (var (name, type, _) in properties)
        {
            if (!first) sb.Append(',');
            sb.Append($"\"{name}\":{{\"type\":\"{type}\"}}");
            first = false;
        }

        sb.Append("},\"required\":[");

        var requiredProps = properties.Where(p => p.required).Select(p => $"\"{p.name}\"");
        sb.Append(string.Join(",", requiredProps));

        sb.Append("]}");

        return sb.ToString();
    }

    private static string GetJsonSchemaType(ITypeSymbol type)
    {
        // Handle nullable types
        if (type.NullableAnnotation == NullableAnnotation.Annotated)
        {
            if (type is INamedTypeSymbol { IsGenericType: true } namedType &&
                namedType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
            {
                return GetJsonSchemaType(namedType.TypeArguments[0]);
            }
        }

        var typeName = type.ToDisplayString();

        return typeName switch
        {
            "string" or "string?" or "System.String" => "string",
            "int" or "System.Int32" or "int?" => "integer",
            "long" or "System.Int64" or "long?" => "integer",
            "short" or "System.Int16" or "short?" => "integer",
            "byte" or "System.Byte" or "byte?" => "integer",
            "float" or "System.Single" or "float?" => "number",
            "double" or "System.Double" or "double?" => "number",
            "decimal" or "System.Decimal" or "decimal?" => "number",
            "bool" or "System.Boolean" or "bool?" => "boolean",
            _ when type is IArrayTypeSymbol => "array",
            _ when IsCollectionType(type) => "array",
            _ => "object"
        };
    }

    private static bool IsCollectionType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol namedType)
        {
            var fullName = namedType.OriginalDefinition.ToDisplayString();
            return fullName.StartsWith("System.Collections.Generic.IEnumerable<") ||
                   fullName.StartsWith("System.Collections.Generic.IList<") ||
                   fullName.StartsWith("System.Collections.Generic.List<") ||
                   fullName.StartsWith("System.Collections.Generic.IReadOnlyList<") ||
                   fullName.StartsWith("System.Collections.Generic.ICollection<");
        }
        return false;
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return name;
        }

        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private static string EscapeVerbatimString(string str)
    {
        return str.Replace("\"", "\"\"");
    }
}
