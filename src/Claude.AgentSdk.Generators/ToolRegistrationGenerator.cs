using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Claude.AgentSdk.Generators;

/// <summary>
///     Source generator that creates compile-time tool registration code for classes
///     marked with [GenerateToolRegistration].
/// </summary>
[Generator]
public sealed class ToolRegistrationGenerator : IIncrementalGenerator
{
    private const string GenerateToolRegistrationAttribute =
        "Claude.AgentSdk.Attributes.GenerateToolRegistrationAttribute";

    private const string ClaudeToolAttribute = "Claude.AgentSdk.Tools.ClaudeToolAttribute";
    private const string ToolParameterAttribute = "Claude.AgentSdk.Attributes.ToolParameterAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [GenerateToolRegistration]
        IncrementalValuesProvider<ClassDeclarationSyntax?> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsCandidateClass(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        IncrementalValueProvider<(Compilation Left, ImmutableArray<ClassDeclarationSyntax?> Right)>
            compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeList in classDeclaration.AttributeLists)
        {
            foreach (AttributeSyntax attribute in attributeList.Attributes)
            {
                ISymbol? symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (symbol is IMethodSymbol methodSymbol)
                {
                    string attributeType = methodSymbol.ContainingType.ToDisplayString();
                    if (attributeType == GenerateToolRegistrationAttribute)
                    {
                        return classDeclaration;
                    }
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes,
        SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (ClassDeclarationSyntax? classDeclaration in classes.Distinct())
        {
            if (classDeclaration is null)
            {
                continue;
            }

            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            INamedTypeSymbol? classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

            if (classSymbol is null)
            {
                continue;
            }

            string source = GenerateToolRegistrationExtension(classSymbol, compilation);
            context.AddSource($"{classSymbol.Name}ToolRegistrationExtensions.g.cs",
                SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateToolRegistrationExtension(INamedTypeSymbol classSymbol, Compilation compilation)
    {
        string className = classSymbol.Name;
        string classNamespace = classSymbol.ContainingNamespace.ToDisplayString();
        string fullClassName = classSymbol.ToDisplayString();

        List<ToolMethodInfo> toolMethods = GetToolMethods(classSymbol, compilation);

        StringBuilder sb = new();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Nodes;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Claude.AgentSdk.Tools;");
        sb.AppendLine();
        sb.AppendLine($"namespace {classNamespace};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"///     Generated tool registration extensions for <see cref=\"{className}\"/>.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class {className}ToolRegistrationExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly JsonSerializerOptions JsonOptions = new()");
        sb.AppendLine("    {");
        sb.AppendLine("        PropertyNameCaseInsensitive = true");
        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(
            $"    ///     Registers all tools from <see cref=\"{className}\"/> using compile-time generated code (no reflection).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"server\">The MCP tool server to register tools with.</param>");
        sb.AppendLine("    /// <param name=\"instance\">The instance containing the tool methods.</param>");
        sb.AppendLine("    /// <returns>The number of tools registered.</returns>");
        sb.AppendLine(
            $"    public static int RegisterToolsCompiled(this McpToolServer server, {fullClassName} instance)");
        sb.AppendLine("    {");

        foreach (ToolMethodInfo? tool in toolMethods)
        {
            sb.AppendLine();
            GenerateToolRegistration(sb, tool);
        }

        sb.AppendLine();
        sb.AppendLine($"        return {toolMethods.Count};");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate GetToolNamesCompiled method
        GenerateGetToolNamesMethod(sb, className, toolMethods);
        sb.AppendLine();

        // Generate GetMcpToolNamesCompiled method
        GenerateGetMcpToolNamesMethod(sb, className, toolMethods);
        sb.AppendLine();

        // Generate GetAllowedToolsCompiled method
        GenerateGetAllowedToolsMethod(sb, className, toolMethods);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static List<ToolMethodInfo> GetToolMethods(INamedTypeSymbol classSymbol, Compilation compilation)
    {
        List<ToolMethodInfo> tools = [];
        INamedTypeSymbol? claudeToolAttributeSymbol = compilation.GetTypeByMetadataName(ClaudeToolAttribute);

        if (claudeToolAttributeSymbol is null)
        {
            return tools;
        }

        foreach (ISymbol? member in classSymbol.GetMembers())
        {
            if (member is not IMethodSymbol methodSymbol)
            {
                continue;
            }

            AttributeData? claudeToolAttr = methodSymbol.GetAttributes()
                .FirstOrDefault(a =>
                    SymbolEqualityComparer.Default.Equals(a.AttributeClass, claudeToolAttributeSymbol));

            if (claudeToolAttr is null)
            {
                continue;
            }

            string name = claudeToolAttr.ConstructorArguments[0].Value?.ToString() ?? methodSymbol.Name;
            string description = claudeToolAttr.ConstructorArguments[1].Value?.ToString() ?? "";

            List<ToolParameterInfo> parameters = [];
            foreach (IParameterSymbol? param in methodSymbol.Parameters)
            {
                if (param.Type.ToDisplayString() == "System.Threading.CancellationToken")
                {
                    continue;
                }

                parameters.Add(new ToolParameterInfo
                {
                    Name = param.Name,
                    Type = param.Type,
                    HasDefaultValue = param.HasExplicitDefaultValue,
                    DefaultValue = param.HasExplicitDefaultValue ? param.ExplicitDefaultValue : null,
                    ParameterAttributes = GetToolParameterAttributes(param, compilation)
                });
            }

            tools.Add(new ToolMethodInfo
            {
                MethodName = methodSymbol.Name,
                ToolName = name,
                Description = description,
                Parameters = parameters,
                ReturnType = methodSymbol.ReturnType,
                IsAsync = methodSymbol.ReturnType.ToDisplayString().StartsWith("System.Threading.Tasks.Task")
            });
        }

        return tools;
    }

    private static ToolParameterAttributeInfo? GetToolParameterAttributes(IParameterSymbol param,
        Compilation compilation)
    {
        INamedTypeSymbol? toolParamAttributeSymbol = compilation.GetTypeByMetadataName(ToolParameterAttribute);
        if (toolParamAttributeSymbol is null)
        {
            return null;
        }

        AttributeData? attr = param.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, toolParamAttributeSymbol));

        if (attr is null)
        {
            return null;
        }

        ToolParameterAttributeInfo info = new();

        foreach (KeyValuePair<string, TypedConstant> namedArg in attr.NamedArguments)
        {
            switch (namedArg.Key)
            {
                case "Description":
                    info.Description = namedArg.Value.Value?.ToString();
                    break;
                case "Example":
                    info.Example = namedArg.Value.Value?.ToString();
                    break;
                case "MinValue":
                    info.MinValue = namedArg.Value.Value as double?;
                    break;
                case "MaxValue":
                    info.MaxValue = namedArg.Value.Value as double?;
                    break;
                case "MinLength":
                    info.MinLength = namedArg.Value.Value as int?;
                    break;
                case "MaxLength":
                    info.MaxLength = namedArg.Value.Value as int?;
                    break;
                case "Pattern":
                    info.Pattern = namedArg.Value.Value?.ToString();
                    break;
            }
        }

        return info;
    }

    private static void GenerateToolRegistration(StringBuilder sb, ToolMethodInfo tool)
    {
        // Generate schema
        sb.AppendLine($"        // Tool: {tool.ToolName}");
        sb.AppendLine($"        var {tool.MethodName}Schema = new JsonObject");
        sb.AppendLine("        {");
        sb.AppendLine("            [\"type\"] = \"object\",");
        sb.AppendLine("            [\"properties\"] = new JsonObject");
        sb.AppendLine("            {");

        foreach (ToolParameterInfo? param in tool.Parameters)
        {
            string jsonType = GetJsonSchemaType(param.Type);
            sb.Append($"                [\"{param.Name}\"] = new JsonObject {{ [\"type\"] = \"{jsonType}\"");

            // Add items type for arrays
            if (jsonType == "array")
            {
                string itemType = GetArrayItemType(param.Type);
                sb.Append($", [\"items\"] = new JsonObject {{ [\"type\"] = \"{itemType}\" }}");
            }

            if (param.ParameterAttributes?.Description != null)
            {
                sb.Append($", [\"description\"] = \"{EscapeString(param.ParameterAttributes.Description)}\"");
            }

            sb.AppendLine(" },");
        }

        sb.AppendLine("            },");
        sb.Append("            [\"required\"] = new JsonArray { ");
        IEnumerable<string> requiredParams =
            tool.Parameters.Where(p => !p.HasDefaultValue).Select(p => $"\"{p.Name}\"");
        sb.Append(string.Join(", ", requiredParams));
        sb.AppendLine(" }");
        sb.AppendLine("        };");
        sb.AppendLine();

        // Generate registration
        sb.AppendLine("        server.RegisterTool(new ToolDefinition");
        sb.AppendLine("        {");
        sb.AppendLine($"            Name = \"{tool.ToolName}\",");
        sb.AppendLine($"            Description = \"{EscapeString(tool.Description)}\",");
        sb.AppendLine($"            InputSchema = {tool.MethodName}Schema,");
        sb.AppendLine("            Handler = async (input, ct) =>");
        sb.AppendLine("            {");

        // Generate parameter extraction
        foreach (ToolParameterInfo? param in tool.Parameters)
        {
            string extraction = GenerateParameterExtraction(param);
            sb.AppendLine($"                {extraction}");
        }

        // Generate validation (if any constraints are specified)
        bool hasValidation = false;
        foreach (ToolParameterInfo? param in tool.Parameters)
        {
            string? validation = GenerateParameterValidation(param);
            if (!string.IsNullOrEmpty(validation))
            {
                if (!hasValidation)
                {
                    sb.AppendLine();
                    sb.AppendLine("                // Parameter validation");
                    hasValidation = true;
                }

                sb.AppendLine(validation);
            }
        }

        // Generate method call
        sb.AppendLine();
        string paramList = string.Join(", ", tool.Parameters.Select(p => p.Name));
        sb.AppendLine(
            tool.IsAsync
                ? $"                var result = await instance.{tool.MethodName}({paramList}).ConfigureAwait(false);"
                : $"                var result = instance.{tool.MethodName}({paramList});");

        // Handle return type
        string returnTypeName = tool.ReturnType.ToDisplayString();
        if (returnTypeName == "Claude.AgentSdk.Tools.ToolResult" ||
            returnTypeName == "System.Threading.Tasks.Task<Claude.AgentSdk.Tools.ToolResult>")
        {
            sb.AppendLine("                return result;");
        }
        else if (returnTypeName == "string" || returnTypeName == "System.Threading.Tasks.Task<string>")
        {
            sb.AppendLine("                return ToolResult.Text(result);");
        }
        else
        {
            sb.AppendLine("                return ToolResult.Text(result?.ToString() ?? \"\");");
        }

        sb.AppendLine("            }");
        sb.AppendLine("        });");
    }

    private static string GenerateParameterExtraction(ToolParameterInfo param)
    {
        string typeName = param.Type.ToDisplayString();
        bool nullable = param.HasDefaultValue || param.Type.NullableAnnotation == NullableAnnotation.Annotated;

        // Handle string types
        if (typeName == "string" || typeName == "string?")
        {
            if (param.HasDefaultValue)
            {
                string defaultStr = param.DefaultValue == null ? "null" : $"\"{param.DefaultValue}\"";
                return
                    $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) ? _{param.Name}.GetString() ?? {defaultStr} : {defaultStr};";
            }

            return $"var {param.Name} = input.GetProperty(\"{param.Name}\").GetString()!;";
        }

        // Handle nullable int
        if (typeName == "int?" || typeName == "System.Nullable<int>" || typeName == "System.Nullable<System.Int32>")
        {
            return
                $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) && _{param.Name}.ValueKind != JsonValueKind.Null ? (int?)_{param.Name}.GetInt32() : null;";
        }

        // Handle non-nullable int
        if (typeName == "int" || typeName == "System.Int32")
        {
            if (param.HasDefaultValue)
            {
                return
                    $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) ? _{param.Name}.GetInt32() : {param.DefaultValue ?? 0};";
            }

            return $"var {param.Name} = input.GetProperty(\"{param.Name}\").GetInt32();";
        }

        // Handle nullable long
        if (typeName == "long?" || typeName == "System.Nullable<long>" || typeName == "System.Nullable<System.Int64>")
        {
            return
                $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) && _{param.Name}.ValueKind != JsonValueKind.Null ? (long?)_{param.Name}.GetInt64() : null;";
        }

        // Handle non-nullable long
        if (typeName == "long" || typeName == "System.Int64")
        {
            if (param.HasDefaultValue)
            {
                return
                    $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) ? _{param.Name}.GetInt64() : {param.DefaultValue ?? 0}L;";
            }

            return $"var {param.Name} = input.GetProperty(\"{param.Name}\").GetInt64();";
        }

        // Handle nullable bool
        if (typeName == "bool?" || typeName == "System.Nullable<bool>" || typeName == "System.Nullable<System.Boolean>")
        {
            return
                $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) && _{param.Name}.ValueKind != JsonValueKind.Null ? (bool?)_{param.Name}.GetBoolean() : null;";
        }

        // Handle non-nullable bool
        if (typeName == "bool" || typeName == "System.Boolean")
        {
            if (param.HasDefaultValue)
            {
                string defaultVal = param.DefaultValue is true ? "true" : "false";
                return
                    $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) ? _{param.Name}.GetBoolean() : {defaultVal};";
            }

            return $"var {param.Name} = input.GetProperty(\"{param.Name}\").GetBoolean();";
        }

        // Handle nullable double
        if (typeName == "double?" || typeName == "System.Nullable<double>" ||
            typeName == "System.Nullable<System.Double>")
        {
            return
                $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) && _{param.Name}.ValueKind != JsonValueKind.Null ? (double?)_{param.Name}.GetDouble() : null;";
        }

        // Handle non-nullable double
        if (typeName == "double" || typeName == "System.Double")
        {
            if (param.HasDefaultValue)
            {
                return
                    $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) ? _{param.Name}.GetDouble() : {param.DefaultValue ?? 0.0};";
            }

            return $"var {param.Name} = input.GetProperty(\"{param.Name}\").GetDouble();";
        }

        // Handle array types (including nullable arrays)
        if (typeName.TrimEnd('?').EndsWith("[]"))
        {
            string baseArrayType = typeName.TrimEnd('?');
            if (param.HasDefaultValue || typeName.EndsWith("?"))
            {
                return
                    $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) && _{param.Name}.ValueKind != JsonValueKind.Null ? JsonSerializer.Deserialize<{baseArrayType}>(_{param.Name}.GetRawText(), JsonOptions) : null;";
            }

            return
                $"var {param.Name} = JsonSerializer.Deserialize<{baseArrayType}>(input.GetProperty(\"{param.Name}\").GetRawText(), JsonOptions)!;";
        }

        // Complex type - deserialize
        if (param.HasDefaultValue || typeName.EndsWith("?"))
        {
            string baseType = typeName.TrimEnd('?');
            return
                $"var {param.Name} = input.TryGetProperty(\"{param.Name}\", out var _{param.Name}) && _{param.Name}.ValueKind != JsonValueKind.Null ? JsonSerializer.Deserialize<{baseType}>(_{param.Name}.GetRawText(), JsonOptions) : default;";
        }

        return
            $"var {param.Name} = JsonSerializer.Deserialize<{typeName}>(input.GetProperty(\"{param.Name}\").GetRawText(), JsonOptions)!;";
    }

    private static string? GenerateParameterValidation(ToolParameterInfo param)
    {
        ToolParameterAttributeInfo? attrs = param.ParameterAttributes;
        if (attrs is null)
        {
            return null;
        }

        List<string> validations = [];
        string typeName = param.Type.ToDisplayString().TrimEnd('?');
        bool isNullable = param.HasDefaultValue || param.Type.NullableAnnotation == NullableAnnotation.Annotated;

        // String length validations
        if (typeName == "string")
        {
            if (attrs.MinLength.HasValue)
            {
                string check = isNullable
                    ? $"{param.Name} is not null && {param.Name}.Length < {attrs.MinLength.Value}"
                    : $"{param.Name}.Length < {attrs.MinLength.Value}";
                validations.Add(
                    $"                if ({check}) return ToolResult.Error($\"Parameter '{param.Name}' must have minimum length of {attrs.MinLength.Value}\");");
            }

            if (attrs.MaxLength.HasValue)
            {
                string check = isNullable
                    ? $"{param.Name} is not null && {param.Name}.Length > {attrs.MaxLength.Value}"
                    : $"{param.Name}.Length > {attrs.MaxLength.Value}";
                validations.Add(
                    $"                if ({check}) return ToolResult.Error($\"Parameter '{param.Name}' must have maximum length of {attrs.MaxLength.Value}\");");
            }

            if (!string.IsNullOrEmpty(attrs.Pattern))
            {
                string escapedPattern = EscapeString(attrs.Pattern!);
                string check = isNullable
                    ? $"{param.Name} is not null && !System.Text.RegularExpressions.Regex.IsMatch({param.Name}, @\"{escapedPattern}\")"
                    : $"!System.Text.RegularExpressions.Regex.IsMatch({param.Name}, @\"{escapedPattern}\")";
                validations.Add(
                    $"                if ({check}) return ToolResult.Error($\"Parameter '{param.Name}' must match pattern '{escapedPattern}'\");");
            }
        }

        // Numeric range validations
        if (typeName is "int" or "System.Int32" or "long" or "System.Int64" or "double" or "System.Double" or "float"
            or "System.Single" or "decimal" or "System.Decimal")
        {
            if (attrs.MinValue.HasValue)
            {
                string check = isNullable
                    ? $"{param.Name}.HasValue && {param.Name}.Value < {attrs.MinValue.Value}"
                    : $"{param.Name} < {attrs.MinValue.Value}";
                validations.Add(
                    $"                if ({check}) return ToolResult.Error($\"Parameter '{param.Name}' must be at least {attrs.MinValue.Value}\");");
            }

            if (attrs.MaxValue.HasValue)
            {
                string check = isNullable
                    ? $"{param.Name}.HasValue && {param.Name}.Value > {attrs.MaxValue.Value}"
                    : $"{param.Name} > {attrs.MaxValue.Value}";
                validations.Add(
                    $"                if ({check}) return ToolResult.Error($\"Parameter '{param.Name}' must be at most {attrs.MaxValue.Value}\");");
            }
        }

        // Array length validations
        if (typeName.EndsWith("[]"))
        {
            if (attrs.MinLength.HasValue)
            {
                string check = isNullable
                    ? $"{param.Name} is not null && {param.Name}.Length < {attrs.MinLength.Value}"
                    : $"{param.Name}.Length < {attrs.MinLength.Value}";
                validations.Add(
                    $"                if ({check}) return ToolResult.Error($\"Parameter '{param.Name}' must have at least {attrs.MinLength.Value} items\");");
            }

            if (attrs.MaxLength.HasValue)
            {
                string check = isNullable
                    ? $"{param.Name} is not null && {param.Name}.Length > {attrs.MaxLength.Value}"
                    : $"{param.Name}.Length > {attrs.MaxLength.Value}";
                validations.Add(
                    $"                if ({check}) return ToolResult.Error($\"Parameter '{param.Name}' must have at most {attrs.MaxLength.Value} items\");");
            }
        }

        return validations.Count > 0 ? string.Join("\n", validations) : null;
    }

    private static string GetJsonSchemaType(ITypeSymbol type)
    {
        string typeName = type.ToDisplayString();

        // Handle nullable types - strip the ? suffix for comparison
        string baseTypeName = typeName.TrimEnd('?');

        return baseTypeName switch
        {
            "string" => "string",
            "int" or "System.Int32" or "long" or "System.Int64" => "integer",
            "float" or "System.Single" or "double" or "System.Double" or "decimal" or "System.Decimal" => "number",
            "bool" or "System.Boolean" => "boolean",
            _ when baseTypeName.EndsWith("[]") => "array",
            _ when typeName.StartsWith("System.Nullable<") => GetJsonSchemaTypeFromNullable(typeName),
            _ => "object"
        };
    }

    private static string GetJsonSchemaTypeFromNullable(string typeName)
    {
        // Extract inner type from System.Nullable<T>
        int innerStart = typeName.IndexOf('<') + 1;
        int innerEnd = typeName.LastIndexOf('>');
        if (innerStart > 0 && innerEnd > innerStart)
        {
            string innerType = typeName.Substring(innerStart, innerEnd - innerStart);
            return innerType switch
            {
                "int" or "System.Int32" or "long" or "System.Int64" => "integer",
                "float" or "System.Single" or "double" or "System.Double" or "decimal" or "System.Decimal" => "number",
                "bool" or "System.Boolean" => "boolean",
                _ => "object"
            };
        }

        return "object";
    }

    private static string GetArrayItemType(ITypeSymbol type)
    {
        string typeName = type.ToDisplayString().TrimEnd('?');

        // Remove the [] suffix to get element type
        if (typeName.EndsWith("[]"))
        {
            string elementTypeName = typeName.Substring(0, typeName.Length - 2);
            return elementTypeName switch
            {
                "string" => "string",
                "int" or "System.Int32" or "long" or "System.Int64" => "integer",
                "float" or "System.Single" or "double" or "System.Double" or "decimal" or "System.Decimal" => "number",
                "bool" or "System.Boolean" => "boolean",
                _ when elementTypeName.EndsWith("[]") => "array",
                _ => "object"
            };
        }

        return "object";
    }

    private static string EscapeString(string str)
    {
        return str.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    private static void GenerateGetToolNamesMethod(StringBuilder sb, string className, List<ToolMethodInfo> toolMethods)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(
            $"    ///     Gets the tool names from <see cref=\"{className}\"/> as a compile-time generated list.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"instance\">The instance (used only for extension method syntax).</param>");
        sb.AppendLine("    /// <returns>A read-only list of tool names.</returns>");
        sb.AppendLine($"    public static IReadOnlyList<string> GetToolNamesCompiled(this {className} instance)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new[]");
        sb.AppendLine("        {");

        foreach (ToolMethodInfo? tool in toolMethods)
        {
            sb.AppendLine($"            \"{tool.ToolName}\",");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private static void GenerateGetMcpToolNamesMethod(StringBuilder sb, string className,
        List<ToolMethodInfo> toolMethods)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(
            $"    ///     Gets the MCP-prefixed tool names from <see cref=\"{className}\"/> for use in AllowedTools.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"instance\">The instance (used only for extension method syntax).</param>");
        sb.AppendLine("    /// <param name=\"serverName\">The MCP server name to use in the prefix.</param>");
        sb.AppendLine(
            "    /// <returns>A read-only list of MCP-prefixed tool names in the format \"mcp__{serverName}__{toolName}\".</returns>");
        sb.AppendLine(
            $"    public static IReadOnlyList<string> GetMcpToolNamesCompiled(this {className} instance, string serverName)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new[]");
        sb.AppendLine("        {");

        foreach (ToolMethodInfo? tool in toolMethods)
        {
            sb.AppendLine($"            $\"mcp__{{serverName}}__{tool.ToolName}\",");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private static void GenerateGetAllowedToolsMethod(StringBuilder sb, string className,
        List<ToolMethodInfo> toolMethods)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(
            $"    ///     Gets tool names from <see cref=\"{className}\"/> formatted for direct use in ClaudeAgentOptions.AllowedTools.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"instance\">The instance (used only for extension method syntax).</param>");
        sb.AppendLine("    /// <param name=\"serverName\">The MCP server name to use in the prefix.</param>");
        sb.AppendLine("    /// <returns>An array of MCP-prefixed tool names suitable for AllowedTools.</returns>");
        sb.AppendLine(
            $"    public static string[] GetAllowedToolsCompiled(this {className} instance, string serverName)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new[]");
        sb.AppendLine("        {");

        foreach (ToolMethodInfo? tool in toolMethods)
        {
            sb.AppendLine($"            $\"mcp__{{serverName}}__{tool.ToolName}\",");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private sealed class ToolMethodInfo
    {
        public required string MethodName { get; init; }
        public required string ToolName { get; init; }
        public required string Description { get; init; }
        public required List<ToolParameterInfo> Parameters { get; init; }
        public required ITypeSymbol ReturnType { get; init; }
        public bool IsAsync { get; init; }
    }

    private sealed class ToolParameterInfo
    {
        public required string Name { get; init; }
        public required ITypeSymbol Type { get; init; }
        public bool HasDefaultValue { get; init; }
        public object? DefaultValue { get; init; }
        public ToolParameterAttributeInfo? ParameterAttributes { get; init; }
    }

    private sealed class ToolParameterAttributeInfo
    {
        public string? Description { get; set; }
        public string? Example { get; set; }
        public double? MinValue { get; set; }
        public double? MaxValue { get; set; }
        public int? MinLength { get; set; }
        public int? MaxLength { get; set; }
        public string? Pattern { get; set; }
    }
}
